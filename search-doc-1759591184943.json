{"searchDocs":[{"title":"InstanceList","type":0,"sectionRef":"#","url":"/sandboxer/api/InstanceList","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#properties","content":" ","version":null,"tagName":"h2"},{"title":"DisallowedClasses​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#DisallowedClasses","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; InstanceList.DisallowedClasses: {string} A list of classes that are not allowed to be created byInstance.new nor Instance.fromExisting. Items can be added to the list, but it cannot be overwritten. Changes to this list will be reflected in the sandbox, even if they are made after the sandbox has been initialized. However, if an Instance of a disallowed class is already created, it will continue to function as normal.  ","version":null,"tagName":"h3"},{"title":"ForbiddenClasses​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#ForbiddenClasses","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; InstanceList.ForbiddenClasses: {string} A list of classes that are not allowed to be accessed via the sandbox, period. Every time an Instance reference is accessed, its class will be checked against this list using IsA. If it matches any of the classes in this list, nil will be returned instead. Items can be added to the list, but it cannot be overwritten. Changes to this list will be reflected in the sandbox, even if they are made after the sandbox has been initialized. However, if an Instance of a forbidden class is already referenced in a variable it will continue to function as normal.  ","version":null,"tagName":"h3"},{"title":"ExplicitDisallow​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#ExplicitDisallow","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; InstanceList.ExplicitDisallow: {[Instance ]: boolean} A list of Instances that are explicitly disallowed in the sandbox. This is a mapping of Instances to boolean values, which indicate whether the Instance's descendants are allowed or not. Items can be added to the list, but it cannot be overwritten. Changes to this list will be reflected in the sandbox, even if they are made after the sandbox has been initialized. However, if a blocked Instance is already wrapped, it will continue to function as normal.  ","version":null,"tagName":"h3"},{"title":"Allow​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#Allow","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; InstanceList.Allow: {[Instance ]: boolean} A list of Instances that are allowed in the sandbox. This is a mapping of Instances to boolean values, which indicate whether the Instance's descendants are allowed or not. If any Instance is present in this list, but it is disallowed in ExplicitDisallow, it will be disallowed in the sandbox. Items can be added to the list, but it cannot be overwritten. Changes to this list will be reflected in the sandbox, even if they are made after the sandbox has been initialized. However, if a blocked Instance is already wrapped, it will continue to function as normal. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#functions","content":" ","version":null,"tagName":"h2"},{"title":"instanceAllowed​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#instanceAllowed","content":"&lt;/&gt; InstanceList.instanceAllowed( inst: Instance -- The Instance to check. ) → boolean Checks if an Instance is allowed in the sandbox based on Allow, ExplicitDisallow, and ForbiddenClasses. ","version":null,"tagName":"h3"},{"title":"Sandboxer","type":0,"sectionRef":"#","url":"/sandboxer/api/Sandboxer","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#functions","content":" ","version":null,"tagName":"h2"},{"title":"EditDefaultSandbox​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#EditDefaultSandbox","content":"&lt;/&gt; Sandboxer.EditDefaultSandbox( config: {[string]: any}-- A table containing the configuration for the sandbox. ) → boolean-- Whether the operation was completely successful. Edits the default sandbox configuration. This is used to add or remove certain globals in the sandbox environment. The config is saved and will be used for all future sandboxes made AFTER this function is called. Calls to this will overwrite previous values, if any. Due to dictionary limitations, values cannot be set to nil. To remove a global, set the value to false. The following globals are always removed from the sandbox: getfenv setfenv loadstring newproxy debug (library), debug.info, &amp; debug.traceback Attempting to add these functions/libraries will result in them being ignored. However, you can set them to other values, such as a custom function. This will also allow you to overwrite already sandboxed globals, such as game. The sandboxer will make no attempt to secure custom functions, so use them at your own risk. The only change that will occur is that if the function returns Instances, they will be wrapped, and if wrapped Instances are passed to the function, they will be unwrapped. Do note that the environment table passed to setfenv does NOT have a metatable, unlike Roblox's default environment. The function will return true if the operation was completely successful (i.e., all values were set on the configuration table) and false if any of the keys or values were forbidden globals. The table is NOT recursively checked for forbidden globals. If you manage to bypass the checks, you are responsible for any consequences.  ","version":null,"tagName":"h3"},{"title":"Init​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#Init","content":"&lt;/&gt; Sandboxer:Init() → () Initializes the sandbox environment for the calling script. The following globals are removed: SharedTable debug library getfenv setfenv loadstring newproxy xpcall (note: use pcall instead) All other globals are set to sandboxed versions of the originals. A separate table is created for _G / shared  ","version":null,"tagName":"h3"},{"title":"Sandbox​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#Sandbox","content":"&lt;/&gt; Sandboxer:Sandbox( fnOrLevel: InstanceSandboxer.AnyFn | number-- The function to sandbox or the level to sandbox at. ) → () Sandboxes the given function or the calling script at the specified level. Level Definition 1 function calling Sandboxer:Sandbox 2 caller of the above function 3... etc.  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer##","content":"Type\tDescription&quot;level must be at least 1&quot;\tIf fnOrLevel is a number, it must be at least 1.  ","version":null,"tagName":"h3"},{"title":"SandboxString​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#SandboxString","content":"&lt;/&gt; Sandboxer:SandboxString( src: string,-- The specified string to be loaded as Luau code. chunkname: string-- An optional chunk name for error messages and debug information. ) → InstanceSandboxer.AnyFn Loads the Luau chunk src as a function using loadstring and sandboxes it. ServerScriptService.LoadStringEnabled must be truefor this to work as per the loadstring rules. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer##","content":"Type\tDescription&quot;loadstring() is not available&quot;\tServerScriptService.LoadStringEnabled was false. ","version":null,"tagName":"h3"},{"title":"InstanceSandboxer","type":0,"sectionRef":"#","url":"/sandboxer/api/InstanceSandboxer","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#types","content":" ","version":null,"tagName":"h2"},{"title":"AnyFn​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#AnyFn","content":"&lt;/&gt; type AnyFn = (...any) → ...any Function type that all functions can be reduced to. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#functions","content":" ","version":null,"tagName":"h2"},{"title":"unwrap​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#unwrap","content":"&lt;/&gt; InstanceSandboxer.unwrap( a: any-- The wrapped Instance or RBXScriptSignal to unwrap. ) → (Instance | RBXScriptSignal )? Unwraps a wrapped Instance or RBXScriptSignal. If the Instance or RBXScriptSignal is not wrapped, it will return nil.  ","version":null,"tagName":"h3"},{"title":"isWrapped​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#isWrapped","content":"&lt;/&gt; InstanceSandboxer.isWrapped(a: any) → boolean Checks if a is a wrapped Instance.  ","version":null,"tagName":"h3"},{"title":"isWrappedSignal​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#isWrappedSignal","content":"&lt;/&gt; InstanceSandboxer.isWrappedSignal(a: any) → boolean Checks if a is a wrapped RBXScriptSignal.  ","version":null,"tagName":"h3"},{"title":"deepWrap​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#deepWrap","content":"&lt;/&gt; InstanceSandboxer.deepWrap( v: any,-- The value to deeply wrap. instance: Instance? ,-- The Instance if wrapping one of its properties, methods, or events. key: string?,-- The key of the property, method, or event being wrapped, if applicable. pvisited: {[any]: any}? ) → any Deeply wraps v if it is a table, wrapping Instances and RBXScriptSignals as needed. If v is an Instance or RBXScriptSignal, it will be wrapped and returned.  ","version":null,"tagName":"h3"},{"title":"deepUnwrap​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#deepUnwrap","content":"&lt;/&gt; InstanceSandboxer.deepUnwrap( v: any,-- The value to deeply unwrap. pvisited: {[any]: any}? ) → any Deeply unwraps v if it is a table, unwrapping Instances and RBXScriptSignals as needed. If v is a wrapped Instance or RBXScriptSignal, it will be unwrapped and returned.  ","version":null,"tagName":"h3"},{"title":"unwrapArgs​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#unwrapArgs","content":"&lt;/&gt; InstanceSandboxer.unwrapArgs(...: any) → ...any Deeply unwraps all arguments passed to the function (usually from inside the sandbox), making them ready to be used in a method call on an Instance.  ","version":null,"tagName":"h3"},{"title":"wrapArgs​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#wrapArgs","content":"&lt;/&gt; InstanceSandboxer.wrapArgs(...: any) → ...any Deeply wraps all arguments passed to the function, making them ready to be returned to the sandboxed environment.  ","version":null,"tagName":"h3"},{"title":"wrapFn​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#wrapFn","content":"&lt;/&gt; InstanceSandboxer.wrapFn( fn: AnyFn-- The function to wrap. ) → AnyFn-- The wrapped function. Wraps a function in a proxy that allows it to be safely used in the sandbox. The wrapped function will return wrapped arguments when called.  ","version":null,"tagName":"h3"},{"title":"reverseWrapFn​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#reverseWrapFn","content":"&lt;/&gt; InstanceSandboxer.reverseWrapFn( fn: AnyFn-- The function to wrap. ) → AnyFn-- The wrapped function. Wraps a function in a proxy that allows it to be safely used outside the sandbox. This is mainly used for callbacks being added to stuff like BindableFunctions.  ","version":null,"tagName":"h3"},{"title":"wrapEvent​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#wrapEvent","content":"&lt;/&gt; InstanceSandboxer.wrapEvent( signal: RBXScriptSignal ,-- The RBXScriptSignal to wrap. name: string-- The name of the signal, used for debugging purposes and printing out to console. ) → any-- The wrapped RBXScriptSignal. Wraps an RBXScriptSignal in a proxy that allows it to be safely used in the sandbox. The proxy will have the same methods as an RBXScriptSignal, but will return wrapped arguments when the signal is fired.  ","version":null,"tagName":"h3"},{"title":"wrapInstance​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#wrapInstance","content":"&lt;/&gt; InstanceSandboxer.wrapInstance( instance: Instance -- The Instance to wrap. ) → any-- The wrapped Instance. Wraps an Instance in a proxy that allows it to be safely used in the sandbox. The proxy will have the same properties, methods, and events as the Instance, but will return wrapped arguments when accessed.  ","version":null,"tagName":"h3"},{"title":"hookFunction​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#hookFunction","content":"&lt;/&gt; InstanceSandboxer.hookFunction( inst: Instance ,-- The instance to hook the function on. name: string,-- The name of the function to hook. hook: (( origFn: (A...) → (R...), A... ) → R...?)?-- The hook function, or nil to remove the previous hook. ) → () Hooks a function on the given instance. The hook will only work within the sandbox. If you want to hook all calls to a method on all Instances of a class, use METHOD_CACHE instead. Read the Sandboxer source at the bottom where HttpService is hooked for an example. If used incorrectly, this can be unsafe. Read below, and use with caution. Info This API is intended to be called from outside the sandbox (trusted code). It lets you interpose logic before / after an instance method call that originates from sandboxed code. The provided hook is invoked with the following parameters: hook(origFn, ...) origFn (function): The original unwrapped Roblox function belonging to inst. It must be called with the raw instance as its first parameter if you invoke it manually: origFn(inst, ...). ...: The raw arguments exactly as they were supplied by the sandboxed caller after Luau's implicit : desugaring (i.e. the first vararg is the wrapped proxy for inst). Remember that sandboxed code can still do something like Instance1.Destroy(Instance2). Important: The hook receives the wrapped proxy as its first variadic argument, not the raw Instance. Because origFn expects the actual Instance as the first parameter, do not forward the wrapped proxy directly. Instead, use the captured inst you supplied to hookFunction: InstanceSandboxer.hookFunction(part, &quot;Destroy&quot;, function(orig, selfProxy) print(&quot;Intercepted Destroy for&quot;, part:GetFullName()) -- custom logic orig(part) -- call underlying method safely end) Return Values Whatever the hook returns is forwarded (after normal sandbox wrapping) to the sandboxed caller. If you want to preserve original behavior, return the results of origFn: return origFn(inst, ...) Removing a Hook Pass nil as the hook argument to remove a previously installed hook: InstanceSandboxer.hookFunction(part, &quot;Destroy&quot;, nil) Errors If the named member does not exist or is not a function, this call errors. Hooks replace one another: only one hook per (Instance, methodName) pair is stored. Limitations / Security Notes Hooks are not visible to sandboxed code except through changed behavior. However, if sandboxed code checks another Instance of the same class' methods, it may observe that the functions are not equal and thus one has been hooked. Hooks execute with full trust; ensure any values you return are properly wrapped if you manually bypass origFn. Because arguments arrive in wrapped form (first arg is a proxy), prefer using the outer inst variable when invoking origFn. Re-entrant calls to the same method on the proxy from inside a hook will also trigger the hook. Make sure to use the origFn provided.  ","version":null,"tagName":"h3"}],"options":{"id":"default"}}