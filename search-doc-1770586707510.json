{"searchDocs":[{"title":"Sandboxer","type":0,"sectionRef":"#","url":"/sandboxer/api/Sandboxer","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#functions","content":" ","version":null,"tagName":"h2"},{"title":"EditDefaultSandbox​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#EditDefaultSandbox","content":"&lt;/&gt; Sandboxer.EditDefaultSandbox( config: {[string]: any}-- A table containing the configuration for the sandbox. ) → boolean-- Whether the operation was completely successful. Edits the default sandbox configuration. This is used to add or remove certain globals in the sandbox environment. The config is saved and will be used for all future sandboxes made AFTER this function is called. Calls to this will overwrite previous values, if any. Due to dictionary limitations, values cannot be set to nil. To remove a global, set the value to false. The following globals are always removed from the sandbox: getfenv setfenv loadstring newproxy debug (library), debug.info, &amp; debug.traceback Attempting to add these functions/libraries will result in them being ignored. However, you can set them to other values, such as a custom function. This will also allow you to overwrite already sandboxed globals, such as game. The sandboxer will make no attempt to secure custom functions, so use them at your own risk. The only change that will occur is that if the function returns Instances, they will be wrapped, and if wrapped Instances are passed to the function, they will be unwrapped. Do note that the environment table passed to setfenv does NOT have a metatable, unlike Roblox's default environment. The function will return true if the operation was completely successful (i.e., all values were set on the configuration table) and false if any of the keys or values were forbidden globals. The table is NOT recursively checked for forbidden globals. If you manage to bypass the checks, you are responsible for any consequences.  ","version":null,"tagName":"h3"},{"title":"Init​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#Init","content":"&lt;/&gt; Sandboxer:Init() → () Initializes the sandbox environment for the calling script. The following globals are removed: SharedTable debug library getfenv setfenv loadstring newproxy xpcall (note: use pcall instead) All other globals are set to sandboxed versions of the originals. A separate table is created for _G / shared  ","version":null,"tagName":"h3"},{"title":"Sandbox​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#Sandbox","content":"&lt;/&gt; Sandboxer:Sandbox( fnOrLevel: InstanceSandboxer.AnyFn | number-- The function to sandbox or the level to sandbox at. ) → () Sandboxes the given function or the calling script at the specified level. Level Definition 1 function calling Sandboxer:Sandbox 2 caller of the above function 3... etc.  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer##","content":"Type\tDescription&quot;level must be at least 1&quot;\tIf fnOrLevel is a number, it must be at least 1.  ","version":null,"tagName":"h3"},{"title":"SandboxString​","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer#SandboxString","content":"&lt;/&gt; Sandboxer:SandboxString( src: string,-- The specified string to be loaded as Luau code. chunkname: string-- An optional chunk name for error messages and debug information. ) → InstanceSandboxer.AnyFn Loads the Luau chunk src as a function using loadstring and sandboxes it. ServerScriptService.LoadStringEnabled must be truefor this to work as per the loadstring rules. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Sandboxer","url":"/sandboxer/api/Sandboxer##","content":"Type\tDescription&quot;loadstring() is not available&quot;\tServerScriptService.LoadStringEnabled was false. ","version":null,"tagName":"h3"},{"title":"InstanceList","type":0,"sectionRef":"#","url":"/sandboxer/api/InstanceList","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#properties","content":" ","version":null,"tagName":"h2"},{"title":"DisallowedClasses​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#DisallowedClasses","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; InstanceList.DisallowedClasses: {string} A list of classes that are not allowed to be created byInstance.new nor Instance.fromExisting. Items can be added to the list, but it cannot be overwritten. Changes to this list will be reflected in the sandbox, even if they are made after the sandbox has been initialized. However, if an Instance of a disallowed class is already created, it will continue to function as normal.  ","version":null,"tagName":"h3"},{"title":"ForbiddenClasses​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#ForbiddenClasses","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; InstanceList.ForbiddenClasses: {string} A list of classes that are not allowed to be accessed via the sandbox, period. Every time an Instance reference is accessed, its class will be checked against this list, respecting inheritance by using IsA. If it matches any of the classes in this list, nil will be returned instead. Items can be added to the list, but it cannot be overwritten. Changes to this list will be reflected in the sandbox, even if they are made after the sandbox has been initialized. However, if an Instance of a forbidden class is already referenced in a variable it will continue to function as normal.  ","version":null,"tagName":"h3"},{"title":"ExplicitDisallow​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#ExplicitDisallow","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; InstanceList.ExplicitDisallow: {[Instance ]: boolean} A list of Instances that are explicitly disallowed in the sandbox. This is a mapping of Instances to boolean values, which indicate whether the Instance's descendants are allowed or not. Items can be added to the list, but it cannot be overwritten. Changes to this list will be reflected in the sandbox, even if they are made after the sandbox has been initialized. However, if a blocked Instance is already wrapped, it will continue to function as normal.  ","version":null,"tagName":"h3"},{"title":"Allow​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#Allow","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; InstanceList.Allow: {[Instance ]: boolean} A list of Instances that are allowed in the sandbox. This is a mapping of Instances to boolean values, which indicate whether the Instance's descendants are allowed or not. If any Instance is present in this list, but it is disallowed in ExplicitDisallow, it will be disallowed in the sandbox. Items can be added to the list, but it cannot be overwritten. Changes to this list will be reflected in the sandbox, even if they are made after the sandbox has been initialized. However, if a blocked Instance is already wrapped, it will continue to function as normal. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#functions","content":" ","version":null,"tagName":"h2"},{"title":"instanceAllowed​","type":1,"pageTitle":"InstanceList","url":"/sandboxer/api/InstanceList#instanceAllowed","content":"&lt;/&gt; InstanceList.instanceAllowed( inst: Instance -- The Instance to check. ) → boolean Checks if an Instance is allowed in the sandbox based on Allow, ExplicitDisallow, and ForbiddenClasses. ","version":null,"tagName":"h3"},{"title":"InstanceSandboxer","type":0,"sectionRef":"#","url":"/sandboxer/api/InstanceSandboxer","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#types","content":" ","version":null,"tagName":"h2"},{"title":"AnyFn​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#AnyFn","content":"&lt;/&gt; type AnyFn = (...any) → ...any Function type that all functions can be reduced to.  ","version":null,"tagName":"h3"},{"title":"MetamethodHook​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#MetamethodHook","content":"&lt;/&gt; type MetamethodHook = ( inst: any, fn: ( Instance , ...any ) → ...any, ...any ) → ...any Type for metamethod hook functions. First argument is the original metamethod function that can be called. This function expects an unwrapped Instance as its first argument. Second argument is the wrapped Instance. Remaining arguments are the arguments passed to the metamethod at invocation. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#functions","content":" ","version":null,"tagName":"h2"},{"title":"unwrap​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#unwrap","content":"&lt;/&gt; InstanceSandboxer.unwrap( a: any-- The wrapped Instance or RBXScriptSignal to unwrap. ) → (Instance | RBXScriptSignal )? Unwraps a wrapped Instance or RBXScriptSignal. If the Instance or RBXScriptSignal is not wrapped, it will return nil.  ","version":null,"tagName":"h3"},{"title":"isWrapped​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#isWrapped","content":"&lt;/&gt; InstanceSandboxer.isWrapped(a: any) → boolean Checks if a is a wrapped Instance.  ","version":null,"tagName":"h3"},{"title":"isWrappedSignal​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#isWrappedSignal","content":"&lt;/&gt; InstanceSandboxer.isWrappedSignal(a: any) → boolean Checks if a is a wrapped RBXScriptSignal.  ","version":null,"tagName":"h3"},{"title":"deepWrap​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#deepWrap","content":"&lt;/&gt; InstanceSandboxer.deepWrap( v: any,-- The value to deeply wrap. instance: Instance? ,-- The Instance if wrapping one of its properties, methods, or events. key: string?,-- The key of the property, method, or event being wrapped, if applicable. pvisited: {[any]: any}?, freeze: boolean? ) → any Deeply wraps v if it is a table, wrapping Instances and RBXScriptSignals as needed. If v is an Instance or RBXScriptSignal, it will be wrapped and returned.  ","version":null,"tagName":"h3"},{"title":"deepUnwrap​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#deepUnwrap","content":"&lt;/&gt; InstanceSandboxer.deepUnwrap( v: any,-- The value to deeply unwrap. pvisited: {[any]: any}? ) → any Deeply unwraps v if it is a table, unwrapping Instances and RBXScriptSignals as needed. If v is a wrapped Instance or RBXScriptSignal, it will be unwrapped and returned.  ","version":null,"tagName":"h3"},{"title":"unwrapArgs​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#unwrapArgs","content":"&lt;/&gt; InstanceSandboxer.unwrapArgs(...: any) → ...any Deeply unwraps all arguments passed to the function (usually from inside the sandbox), making them ready to be used in a method call on an Instance.  ","version":null,"tagName":"h3"},{"title":"wrapArgs​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#wrapArgs","content":"&lt;/&gt; InstanceSandboxer.wrapArgs(...: any) → ...any Deeply wraps all arguments passed to the function, making them ready to be returned to the sandboxed environment.  ","version":null,"tagName":"h3"},{"title":"wrapFn​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#wrapFn","content":"&lt;/&gt; InstanceSandboxer.wrapFn( fn: AnyFn-- The function to wrap. ) → AnyFn-- The wrapped function. Wraps a function in a proxy that allows it to be safely used in the sandbox. The wrapped function will return wrapped arguments when called.  ","version":null,"tagName":"h3"},{"title":"reverseWrapFn​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#reverseWrapFn","content":"&lt;/&gt; InstanceSandboxer.reverseWrapFn( fn: AnyFn-- The function to wrap. ) → AnyFn-- The wrapped function. Wraps a function in a proxy that allows it to be safely used outside the sandbox. This is mainly used for callbacks being added to stuff like BindableFunctions.  ","version":null,"tagName":"h3"},{"title":"wrapEvent​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#wrapEvent","content":"&lt;/&gt; InstanceSandboxer.wrapEvent( signal: RBXScriptSignal ,-- The RBXScriptSignal to wrap. name: string-- The name of the signal, used for debugging purposes and printing out to console. ) → any-- The wrapped RBXScriptSignal. Wraps an RBXScriptSignal in a proxy that allows it to be safely used in the sandbox. The proxy will have the same methods as an RBXScriptSignal, but will return wrapped arguments when the signal is fired.  ","version":null,"tagName":"h3"},{"title":"wrapInstance​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#wrapInstance","content":"&lt;/&gt; InstanceSandboxer.wrapInstance( instance: Instance -- The Instance to wrap. ) → any-- The wrapped Instance. Wraps an Instance in a proxy that allows it to be safely used in the sandbox. The proxy will have the same properties, methods, and events as the Instance, but will return wrapped arguments when accessed.  ","version":null,"tagName":"h3"},{"title":"hookMetamethod​","type":1,"pageTitle":"InstanceSandboxer","url":"/sandboxer/api/InstanceSandboxer#hookMetamethod","content":"&lt;/&gt; InstanceSandboxer.hookMetamethod( inst: Instance ,-- Unwrapped Instance to hook. name: Metamethod,-- Metamethod name (with or without __ prefix) to hook. hook: MetamethodHook?-- Callback invoked when the metamethod fires. ) → () Hooks a specific metamethod on a wrapped Instance. Allows for hooking functions on Instances, modifying behaviors, or changing properties within sandboxed code. Safety Guarantees self received by the hook is always the wrapped proxy; it is never auto-unwrapped. Every additional argument reaches the hook untouched; no wrapping, unwrapping, or copying occurs. Return values flow straight back to the sandbox exactly as yielded by the hook; no automatic wrapping occurs. The hook therefore must explicitly call InstanceSandboxer.unwrap, deepUnwrap, wrapInstance, deepWrap, or wrapArgs whenever data crosses the sandbox boundary. It is the caller's responsibility to ensure that this occurs correctly. Behavior The hook completely replaces the default handling of the selected metamethod for inst. The option to revert to conditionally default behavior is available by calling the first argument, which is the original metamethod function. This function expects an unwrapped Instance as its first argument, followed by any additional arguments passed to the metamethod. It is highly recommended to passthrough arguments untouched to avoid unexpected behavior. If the hook does not call the original metamethod function, the default behavior is skipped. Hooks do not chain; setting a hook for a metamethod that already has one overwrites the previous hook. Hooks are per-instance, not inherited. ","version":null,"tagName":"h3"}],"options":{"id":"default"}}