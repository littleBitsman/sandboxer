"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[162],{93:e=>{e.exports=JSON.parse('{"functions":[{"name":"unwrap","desc":"Unwraps a wrapped `Instance` or `RBXScriptSignal`.\\nIf the `Instance` or `RBXScriptSignal` is not wrapped, it will return `nil`.","params":[{"name":"a","desc":"The wrapped `Instance` or `RBXScriptSignal` to unwrap.","lua_type":"any"}],"returns":[{"desc":"","lua_type":"(Instance | RBXScriptSignal)?\\n"}],"function_type":"static","source":{"line":180,"path":"src/InstanceList.luau"}},{"name":"isWrapped","desc":"Checks if `a` is a wrapped `Instance`.","params":[{"name":"a","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\n"}],"function_type":"static","source":{"line":190,"path":"src/InstanceList.luau"}},{"name":"isWrappedSignal","desc":"Checks if `a` is a wrapped `RBXScriptSignal`.","params":[{"name":"a","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\n"}],"function_type":"static","source":{"line":201,"path":"src/InstanceList.luau"}},{"name":"deepWrap","desc":"Deeply wraps `v` if it is a table, wrapping `Instance`s and `RBXScriptSignal`s as needed.\\nIf `v` is an `Instance` or `RBXScriptSignal`, it will be wrapped and returned.","params":[{"name":"v","desc":"The value to deeply wrap.","lua_type":"any"},{"name":"instance","desc":"The `Instance` if wrapping one of its properties, methods, or events.","lua_type":"Instance?"},{"name":"key","desc":"The key of the property, method, or event being wrapped, if applicable.","lua_type":"string?"},{"name":"pvisited","desc":"","lua_type":"{ [any]: any }?"}],"returns":[{"desc":"","lua_type":"any\\n"}],"function_type":"static","source":{"line":82,"path":"src/InstanceSandboxer.luau"}},{"name":"deepUnwrap","desc":"Deeply unwraps `v` if it is a table, unwrapping `Instance`s and `RBXScriptSignal`s as needed.\\nIf `v` is a wrapped `Instance` or `RBXScriptSignal`, it will be unwrapped and returned.","params":[{"name":"v","desc":"The value to deeply unwrap.","lua_type":"any"},{"name":"pvisited","desc":"","lua_type":"{ [any]: any }?"}],"returns":[{"desc":"","lua_type":"any\\n"}],"function_type":"static","source":{"line":123,"path":"src/InstanceSandboxer.luau"}},{"name":"unwrapArgs","desc":"Deeply unwraps all arguments passed to the function (usually\\nfrom inside the sandbox), making them ready to be used in a\\nmethod call on an `Instance`.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"...any\\n"}],"function_type":"static","source":{"line":163,"path":"src/InstanceSandboxer.luau"}},{"name":"wrapArgs","desc":"Deeply wraps all arguments passed to the function, making\\nthem ready to be returned to the sandboxed environment.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"...any\\n"}],"function_type":"static","source":{"line":181,"path":"src/InstanceSandboxer.luau"}},{"name":"wrapFn","desc":"Wraps a function in a proxy that allows it to be safely used in the sandbox.\\nThe wrapped function will return wrapped arguments when called.","params":[{"name":"fn","desc":"The function to wrap.","lua_type":"AnyFn"}],"returns":[{"desc":"The wrapped function.","lua_type":"AnyFn"}],"function_type":"static","source":{"line":202,"path":"src/InstanceSandboxer.luau"}},{"name":"reverseWrapFn","desc":"Wraps a function in a proxy that allows it to be safely used outside the sandbox.\\nThis is mainly used for callbacks being added to stuff like BindableFunctions.","params":[{"name":"fn","desc":"The function to wrap.","lua_type":"AnyFn"}],"returns":[{"desc":"The wrapped function.","lua_type":"AnyFn"}],"function_type":"static","source":{"line":224,"path":"src/InstanceSandboxer.luau"}},{"name":"wrapEvent","desc":"Wraps an `RBXScriptSignal` in a proxy that allows it to be safely used in \\nthe sandbox. The proxy will have the same methods as an `RBXScriptSignal`, \\nbut will return wrapped arguments when the signal is fired.","params":[{"name":"signal","desc":"The `RBXScriptSignal` to wrap.","lua_type":"RBXScriptSignal"},{"name":"name","desc":"The name of the signal, used for debugging purposes and printing out to console.","lua_type":"string"}],"returns":[{"desc":"The wrapped `RBXScriptSignal`.","lua_type":"any"}],"function_type":"static","source":{"line":521,"path":"src/InstanceSandboxer.luau"}},{"name":"wrapInstance","desc":"Wraps an `Instance` in a proxy that allows it to be safely used in the sandbox.\\nThe proxy will have the same properties, methods, and events as the `Instance`, \\nbut will return wrapped arguments when accessed.","params":[{"name":"instance","desc":"The `Instance` to wrap.","lua_type":"Instance"}],"returns":[{"desc":"The wrapped `Instance`.","lua_type":"any"}],"function_type":"static","source":{"line":560,"path":"src/InstanceSandboxer.luau"}},{"name":"hookMetamethod","desc":"Hooks a specific metamethod on a wrapped `Instance`. Allows for hooking functions\\non Instances, modifying behaviors, or changing properties within sandboxed code.\\n\\n### Safety Guarantees\\n- `self` received by the hook is always the wrapped proxy; it is never auto-unwrapped.\\n- Every additional argument reaches the hook untouched; no wrapping, unwrapping, or copying occurs.\\n- Return values flow straight back to the sandbox exactly as yielded by the hook; no automatic wrapping occurs.\\n- The hook therefore must explicitly call `InstanceSandboxer.unwrap`, `deepUnwrap`, `wrapInstance`,\\n  `deepWrap`, or `wrapArgs` whenever data crosses the sandbox boundary. *It is the caller\'s responsibility to\\n  ensure that this occurs correctly.*\\n\\n### Behavior\\n- The hook completely replaces the default handling of the selected metamethod for `inst`.\\n  - The option to revert to conditionally default behavior is available by calling the first argument,\\n    which is the original metamethod function. This function expects an unwrapped `Instance` as its first argument,\\n\\tfollowed by any additional arguments passed to the metamethod. *It is highly recommended to passthrough arguments\\n\\tuntouched to avoid unexpected behavior.*\\n- If the hook does not call the original metamethod function, the default behavior is skipped.\\n- Hooks do not chain; setting a hook for a metamethod that already has one overwrites the previous hook.\\n- Hooks are per-instance, not inherited.","params":[{"name":"inst","desc":"**Unwrapped** Instance to hook.","lua_type":"Instance"},{"name":"name","desc":"Metamethod name (with or without `__` prefix) to hook.","lua_type":"Metamethod"},{"name":"hook","desc":"Callback invoked when the metamethod fires.","lua_type":"MetamethodHook"}],"returns":[],"function_type":"static","source":{"line":672,"path":"src/InstanceSandboxer.luau"}}],"properties":[],"types":[{"name":"AnyFn","desc":"Function type that all functions can be reduced to.","lua_type":"(...any) -> ...any","source":{"line":69,"path":"src/InstanceSandboxer.luau"}},{"name":"MetamethodHook","desc":"Type for metamethod hook functions.\\nFirst argument is the original metamethod function that can be called. **This function expects an unwrapped `Instance` as its first argument.**\\nSecond argument is the wrapped `Instance`.\\nRemaining arguments are the arguments passed to the metamethod at invocation.","lua_type":"(inst: any, fn: (Instance, ...any) -> ...any, ...any) -> ...any","source":{"line":247,"path":"src/InstanceSandboxer.luau"}}],"name":"InstanceSandboxer","desc":"A class for wrapping and unwrapping `Instance`s and `RBXScriptSignal`s.","source":{"line":32,"path":"src/InstanceSandboxer.luau"}}')}}]);