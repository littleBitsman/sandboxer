"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[162],{93:e=>{e.exports=JSON.parse('{"functions":[{"name":"unwrap","desc":"Unwraps a wrapped `Instance` or `RBXScriptSignal`.\\nIf the `Instance` or `RBXScriptSignal` is not wrapped, it will return `nil`.","params":[{"name":"a","desc":"The wrapped `Instance` or `RBXScriptSignal` to unwrap.","lua_type":"any"}],"returns":[{"desc":"","lua_type":"(Instance | RBXScriptSignal)?\\n"}],"function_type":"static","source":{"line":176,"path":"src/InstanceList.luau"}},{"name":"isWrapped","desc":"Checks if `a` is a wrapped `Instance`.","params":[{"name":"a","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\n"}],"function_type":"static","source":{"line":186,"path":"src/InstanceList.luau"}},{"name":"isWrappedSignal","desc":"Checks if `a` is a wrapped `RBXScriptSignal`.","params":[{"name":"a","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\n"}],"function_type":"static","source":{"line":197,"path":"src/InstanceList.luau"}},{"name":"deepWrap","desc":"Deeply wraps `v` if it is a table, wrapping `Instance`s and `RBXScriptSignal`s as needed.\\nIf `v` is an `Instance` or `RBXScriptSignal`, it will be wrapped and returned.","params":[{"name":"v","desc":"The value to deeply wrap.","lua_type":"any"},{"name":"instance","desc":"The `Instance` if wrapping one of its properties, methods, or events.","lua_type":"Instance?"},{"name":"key","desc":"The key of the property, method, or event being wrapped, if applicable.","lua_type":"string?"},{"name":"pvisited","desc":"","lua_type":"{ [any]: any }?"}],"returns":[{"desc":"","lua_type":"any\\n"}],"function_type":"static","source":{"line":80,"path":"src/InstanceSandboxer.luau"}},{"name":"deepUnwrap","desc":"Deeply unwraps `v` if it is a table, unwrapping `Instance`s and `RBXScriptSignal`s as needed.\\nIf `v` is a wrapped `Instance` or `RBXScriptSignal`, it will be unwrapped and returned.","params":[{"name":"v","desc":"The value to deeply unwrap.","lua_type":"any"},{"name":"pvisited","desc":"","lua_type":"{ [any]: any }?"}],"returns":[{"desc":"","lua_type":"any\\n"}],"function_type":"static","source":{"line":121,"path":"src/InstanceSandboxer.luau"}},{"name":"unwrapArgs","desc":"Deeply unwraps all arguments passed to the function (usually\\nfrom inside the sandbox), making them ready to be used in a\\nmethod call on an `Instance`.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"...any\\n"}],"function_type":"static","source":{"line":161,"path":"src/InstanceSandboxer.luau"}},{"name":"wrapArgs","desc":"Deeply wraps all arguments passed to the function, making\\nthem ready to be returned to the sandboxed environment.","params":[{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"...any\\n"}],"function_type":"static","source":{"line":179,"path":"src/InstanceSandboxer.luau"}},{"name":"wrapFn","desc":"Wraps a function in a proxy that allows it to be safely used in the sandbox.\\nThe wrapped function will return wrapped arguments when called.","params":[{"name":"fn","desc":"The function to wrap.","lua_type":"AnyFn"}],"returns":[{"desc":"The wrapped function.","lua_type":"AnyFn"}],"function_type":"static","source":{"line":200,"path":"src/InstanceSandboxer.luau"}},{"name":"reverseWrapFn","desc":"Wraps a function in a proxy that allows it to be safely used outside the sandbox.\\nThis is mainly used for callbacks being added to stuff like BindableFunctions.","params":[{"name":"fn","desc":"The function to wrap.","lua_type":"AnyFn"}],"returns":[{"desc":"The wrapped function.","lua_type":"AnyFn"}],"function_type":"static","source":{"line":222,"path":"src/InstanceSandboxer.luau"}},{"name":"wrapEvent","desc":"Wraps an `RBXScriptSignal` in a proxy that allows it to be safely used in \\nthe sandbox. The proxy will have the same methods as an `RBXScriptSignal`, \\nbut will return wrapped arguments when the signal is fired.","params":[{"name":"signal","desc":"The `RBXScriptSignal` to wrap.","lua_type":"RBXScriptSignal"},{"name":"name","desc":"The name of the signal, used for debugging purposes and printing out to console.","lua_type":"string"}],"returns":[{"desc":"The wrapped `RBXScriptSignal`.","lua_type":"any"}],"function_type":"static","source":{"line":382,"path":"src/InstanceSandboxer.luau"}},{"name":"wrapInstance","desc":"Wraps an `Instance` in a proxy that allows it to be safely used in the sandbox.\\nThe proxy will have the same properties, methods, and events as the `Instance`, \\nbut will return wrapped arguments when accessed.","params":[{"name":"instance","desc":"The `Instance` to wrap.","lua_type":"Instance"}],"returns":[{"desc":"The wrapped `Instance`.","lua_type":"any"}],"function_type":"static","source":{"line":419,"path":"src/InstanceSandboxer.luau"}},{"name":"hookFunction","desc":"Hooks a function on the given instance. \\nThe hook will only work within the sandbox.\\n\\nIf you want to hook all calls to a method on all Instances of a class,\\nuse `METHOD_CACHE` instead. Read the Sandboxer source at the bottom\\nwhere HttpService is hooked for an example.\\n\\n**If used incorrectly, this can be unsafe. Read below, and use with caution.**\\n\\n# Info\\nThis API is intended to be called from *outside* the sandbox (trusted code).\\nIt lets you interpose logic before / after an instance method call that\\noriginates from sandboxed code.\\n\\nThe provided `hook` is invoked with the following parameters:\\n```lua\\nhook(origFn, ...)\\n```\\n- `origFn` (function): The original unwrapped Roblox function belonging to `inst`.\\n  It must be called with the raw instance as its first parameter if you invoke it manually:\\n  `origFn(inst, ...)`.\\n- `...`: The raw arguments exactly as they were supplied by the sandboxed caller *after* Luau\'s\\n  implicit `:` desugaring (i.e. the first vararg is the wrapped proxy for `inst`). *Remember that\\n  sandboxed code can still do something like* `Instance1.Destroy(Instance2)`.\\n\\nImportant: The hook receives the *wrapped* proxy as its first variadic argument, not the raw `Instance`.\\nBecause `origFn` expects the actual `Instance` as the first parameter, do **not** forward the wrapped\\nproxy directly. Instead, use the captured `inst` you supplied to `hookFunction`:\\n```lua\\nInstanceSandboxer.hookFunction(part, \\"Destroy\\", function(orig, selfProxy)\\n\\tprint(\\"Intercepted Destroy for\\", part:GetFullName())\\n\\t-- custom logic\\n\\torig(part) -- call underlying method safely\\nend)\\n```\\n\\n# Return Values\\nWhatever the hook returns is forwarded (after normal sandbox wrapping) to the sandboxed caller.\\nIf you want to preserve original behavior, return the results of `origFn`:\\n```lua\\nreturn origFn(inst, ...)\\n```\\n\\n# Removing a Hook\\nPass `nil` as the `hook` argument to remove a previously installed hook:\\n```lua\\nInstanceSandboxer.hookFunction(part, \\"Destroy\\", nil)\\n```\\n\\n# Errors\\nIf the named member does not exist or is not a function, this call errors.\\nHooks replace one another: only one hook per (`Instance`, `methodName`) pair is stored.\\n\\n# Limitations / Security Notes\\n- Hooks are not visible to sandboxed code except through changed behavior. However,\\n  if sandboxed code checks another Instance of the same class\' methods, it may observe\\n  that the functions are not equal and thus one has been hooked.\\n- Hooks execute with full trust; ensure any values you return are properly wrapped\\n  if you manually bypass `origFn`.\\n- Because arguments arrive in wrapped form (first arg is a proxy), prefer using\\n  the outer `inst` variable when invoking `origFn`.\\n- Re-entrant calls to the same method on the proxy from inside a hook will also \\n  trigger the hook. Make sure to use the `origFn` provided.","params":[{"name":"inst","desc":"The instance to hook the function on.","lua_type":"Instance"},{"name":"name","desc":"The name of the function to hook.","lua_type":"string"},{"name":"hook","desc":"The hook function, or `nil` to remove the previous hook.","lua_type":"((origFn: (A...) -> (R...), A...) -> R...?)?"}],"returns":[],"function_type":"static","source":{"line":567,"path":"src/InstanceSandboxer.luau"}}],"properties":[],"types":[{"name":"AnyFn","desc":"Function type that all functions can be reduced to.","lua_type":"(...any) -> ...any","source":{"line":67,"path":"src/InstanceSandboxer.luau"}}],"name":"InstanceSandboxer","desc":"A class for wrapping and unwrapping `Instance`s and `RBXScriptSignal`s.","source":{"line":32,"path":"src/InstanceSandboxer.luau"}}')}}]);